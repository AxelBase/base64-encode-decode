import{f as c,a as r}from"../chunks/hWZPI7nN.js";import"../chunks/DpboDwhz.js";import{$ as i,a3 as u,_ as b,a4 as v,a5 as y,a6 as a,a1 as o,a2 as n}from"../chunks/BdysBj66.js";import{h as f}from"../chunks/DpzxLHAf.js";import{s as l}from"../chunks/B_ZIPEiT.js";import{b as d}from"../chunks/BFvU-IR9.js";const B=!0,S=Object.freeze(Object.defineProperty({__proto__:null,prerender:B},Symbol.toStringTag,{value:"Module"}));var w=c(`<meta name="description" content="Master Base64 padding rules: why = and == are added, when they're required, and how decoders handle missing or incorrect padding."/> <meta property="og:title" content="How Base64 Padding Works • AxelBase"/> <meta property="og:description" content="Complete guide to Base64 = padding: why it exists, how it's calculated, and common errors."/> <meta property="og:url"/> <meta property="og:type" content="article"/> <meta name="twitter:card" content="summary_large_image"/>`,1),_=c(`<div class="container fade-in post-layout svelte-1al8b51"><div class="breadcrumbs svelte-1al8b51"><a class="svelte-1al8b51">Blog</a> <span>/</span> <p>Base64 Padding Explained</p></div> <article class="prose svelte-1al8b51"><h1 class="svelte-1al8b51">How Base64 Padding Works (and Why It’s Required)</h1> <p class="post-meta svelte-1al8b51">Published: November 21, 2025</p> <p>Padding is one of the most misunderstood aspects of Base64 — yet it's critical for correct decoding. The = character is not random: it's a precise signal about how many bytes were in the original data.</p> <h2 class="svelte-1al8b51">The Math Behind Padding</h2> <p>Base64 processes data in 3-byte chunks → producing 4 output characters. When the input length isn’t divisible by 3:</p> <ul class="svelte-1al8b51"><li><strong>1 byte remaining</strong> → only 2 valid output chars → add ==</li> <li><strong>2 bytes remaining</strong> → 3 valid output chars → add =</li> <li><strong>0 bytes remaining</strong> → no padding needed</li></ul> <h3>Example: Encoding "Hi"</h3> <p>"Hi" = 2 bytes → produces 3 Base64 chars + one =</p> <p>Result: <code>SGk=</code></p> <h2 class="svelte-1al8b51">Why Padding Cannot Be Optional</h2> <p>Without padding, decoders cannot know how many of the final 6-bit groups contain real data. Removing = breaks round-trip integrity.</p> <h2 class="svelte-1al8b51">Common Padding Mistakes</h2> <ul class="svelte-1al8b51"><li>Stripping all = characters (very common!)</li> <li>Adding incorrect number of =</li> <li>Using Base64url and forgetting to re-add padding before decoding</li></ul> <h2 class="svelte-1al8b51">How Smart Decoders Handle It</h2> <p>AxelBase and modern libraries are tolerant: they accept missing padding and infer it from string length (mod 4). But never rely on tolerance — always encode correctly.</p> <h2 class="svelte-1al8b51">FAQ</h2> <details class="svelte-1al8b51"><summary class="svelte-1al8b51">Is it safe to remove padding?</summary> <p>Only if your decoder explicitly supports it. Never assume.</p></details> <details class="svelte-1al8b51"><summary class="svelte-1al8b51">Why do some APIs omit padding?</summary> <p>For brevity in Base64url contexts — but they must document it clearly.</p></details> <p class="italic-note svelte-1al8b51">Correct padding = reliable decoding. Never compromise on it in production systems.</p></article></div>`);function $(p){var e=_();f("1al8b51",g=>{var s=w(),h=u(b(s),6);a(4),i(()=>l(h,"content",`${d??""}/blog/posts/post3`)),v(()=>{y.title="How Base64 Padding Works • AxelBase Technical Guide"}),r(g,s)});var t=o(e),m=o(t);a(4),n(t),a(2),n(e),i(()=>l(m,"href",`${d??""}/blog`)),r(p,e)}export{$ as component,S as universal};
